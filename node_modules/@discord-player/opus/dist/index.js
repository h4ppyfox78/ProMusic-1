"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CTL: () => CTL,
  OPUS_MOD_REGISTRY: () => OPUS_MOD_REGISTRY,
  OpusDecoder: () => OpusDecoder,
  OpusEncoder: () => OpusEncoder,
  OpusStream: () => OpusStream,
  version: () => version
});
module.exports = __toCommonJS(src_exports);
var import_stream = require("stream");
var loadModule = /* @__PURE__ */ __name((modules) => {
  const errors = [];
  for (const [name, fn] of modules) {
    try {
      return {
        ...fn(require(name)),
        name
      };
    } catch (e) {
      errors.push(`Failed to load ${name}: ${e}`);
      continue;
    }
  }
  throw new Error(`Could not load opus module, tried ${modules.length} different modules. Errors: ${errors.join("\n")}`);
}, "loadModule");
var CTL = {
  BITRATE: 4002,
  FEC: 4012,
  PLP: 4014
};
var OPUS_MOD_REGISTRY = [
  [
    "mediaplex",
    (mod) => {
      if (!mod.OpusEncoder)
        throw new Error("Unsupported mediaplex version");
      return { Encoder: mod.OpusEncoder };
    }
  ],
  ["@discordjs/opus", (opus) => ({ Encoder: opus.OpusEncoder })],
  ["node-opus", (opus) => ({ Encoder: opus.OpusEncoder })],
  ["opusscript", (opus) => ({ Encoder: opus })]
];
var Opus = {};
function loadOpus(refresh = false) {
  if (Opus.Encoder && !refresh)
    return Opus;
  Opus = loadModule(OPUS_MOD_REGISTRY);
  return Opus;
}
__name(loadOpus, "loadOpus");
var charCode = /* @__PURE__ */ __name((x) => x.charCodeAt(0), "charCode");
var OPUS_HEAD = Buffer.from([..."OpusHead"].map(charCode));
var OPUS_TAGS = Buffer.from([..."OpusTags"].map(charCode));
var OpusStream = class extends import_stream.Transform {
  constructor(options = {}) {
    if (!loadOpus().Encoder) {
      throw Error(`Could not find an Opus module! Please install one of ${OPUS_MOD_REGISTRY.map((o) => o[0]).join(", ")}.`);
    }
    super(Object.assign({ readableObjectMode: true }, options));
    this.encoder = null;
    const lib = Opus;
    if (lib.name === "opusscript") {
      options.application = lib.Encoder.Application[options.application];
    }
    this.encoder = new lib.Encoder(options.rate, options.channels, options.application);
    this._options = options;
    this._required = this._options.frameSize * this._options.channels * 2;
  }
  _encode(buffer) {
    if (Opus.name === "opusscript") {
      return this.encoder.encode(buffer, this._options.frameSize);
    } else {
      return this.encoder.encode(buffer);
    }
  }
  _decode(buffer) {
    if (Opus.name === "opusscript") {
      return this.encoder.decode(buffer, this._options.frameSize);
    } else {
      return this.encoder.decode(buffer);
    }
  }
  static get type() {
    return Opus.name;
  }
  setBitrate(bitrate) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.BITRATE, Math.min(128e3, Math.max(16e3, bitrate))]);
  }
  setFEC(enabled) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.FEC, enabled ? 1 : 0]);
  }
  setPLP(percentage) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.PLP, Math.min(100, Math.max(0, percentage * 100))]);
  }
  _final(cb) {
    this._cleanup();
    cb();
  }
  _destroy(err, cb) {
    this._cleanup();
    return cb ? cb(err) : void 0;
  }
  _cleanup() {
    if (Opus.name === "opusscript" && this.encoder)
      this.encoder.delete();
    this.encoder = null;
  }
};
__name(OpusStream, "OpusStream");
var OpusEncoder = class extends OpusStream {
  constructor(options = {}) {
    super(options);
    this._buffer = Buffer.alloc(0);
  }
  _transform(chunk, encoding, done) {
    this._buffer = Buffer.concat([this._buffer, chunk]);
    let n = 0;
    while (this._buffer.length >= this._required * (n + 1)) {
      const buf = this._encode(this._buffer.slice(n * this._required, (n + 1) * this._required));
      this.push(buf);
      n++;
    }
    if (n > 0)
      this._buffer = this._buffer.slice(n * this._required);
    return done();
  }
  _destroy(err, cb) {
    super._destroy(err, cb);
    this._buffer = null;
  }
};
__name(OpusEncoder, "OpusEncoder");
var OpusDecoder = class extends OpusStream {
  _transform(chunk, encoding, done) {
    const signature = chunk.slice(0, 8);
    if (chunk.length >= 8 && signature.equals(OPUS_HEAD)) {
      this.emit("format", {
        channels: this._options.channels,
        sampleRate: this._options.rate,
        bitDepth: 16,
        float: false,
        signed: true,
        version: chunk.readUInt8(8),
        preSkip: chunk.readUInt16LE(10),
        gain: chunk.readUInt16LE(16)
      });
      return done();
    }
    if (chunk.length >= 8 && signature.equals(OPUS_TAGS)) {
      this.emit("tags", chunk);
      return done();
    }
    try {
      this.push(this._decode(chunk));
    } catch (e) {
      return done(e);
    }
    return done();
  }
};
__name(OpusDecoder, "OpusDecoder");
var version = "0.1.1";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CTL,
  OPUS_MOD_REGISTRY,
  OpusDecoder,
  OpusEncoder,
  OpusStream,
  version
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYW1pc2hzaGFoL3ByaXNtLW1lZGlhL2Jsb2IvNGVmMWQ2ZjlmNTMwNDJjMDg1YzFmNjg2MjdlODg5MDAzZTI0OGQ3Ny9zcmMvb3B1cy9PcHVzLmpzXG5cbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3N0cmVhbSc7XG5cbmV4cG9ydCB0eXBlIElFbmNvZGVyID0ge1xuICAgIG5ldyAocmF0ZTogbnVtYmVyLCBjaGFubmVsczogbnVtYmVyLCBhcHBsaWNhdGlvbjogbnVtYmVyKToge1xuICAgICAgICBlbmNvZGUoYnVmZmVyOiBCdWZmZXIpOiBCdWZmZXI7XG4gICAgICAgIGVuY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplOiBudW1iZXIpOiBCdWZmZXI7XG4gICAgICAgIGVuY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplPzogbnVtYmVyKTogQnVmZmVyO1xuICAgICAgICBkZWNvZGUoYnVmZmVyOiBCdWZmZXIpOiBCdWZmZXI7XG4gICAgICAgIGRlY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplOiBudW1iZXIpOiBCdWZmZXI7XG4gICAgICAgIGRlY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplPzogbnVtYmVyKTogQnVmZmVyO1xuICAgICAgICBhcHBseUVuY29kZXJDVEw/KGN0bDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogdm9pZDtcbiAgICAgICAgZW5jb2RlckNUTD8oY3RsOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkO1xuICAgICAgICBkZWxldGU/KCk6IHZvaWQ7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIEFwcGxpY2F0aW9uPzogYW55O1xufTtcblxudHlwZSBJTW9kID0gW1xuICAgIHN0cmluZyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIChtb2Q6IGFueSkgPT4ge1xuICAgICAgICBFbmNvZGVyOiBJRW5jb2RlcjtcbiAgICB9XG5dO1xuXG5jb25zdCBsb2FkTW9kdWxlID0gKFxuICAgIG1vZHVsZXM6IElNb2RbXVxuKToge1xuICAgIEVuY29kZXI6IElFbmNvZGVyO1xuICAgIG5hbWU6IHN0cmluZztcbn0gPT4ge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW25hbWUsIGZuXSBvZiBtb2R1bGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICAgICAgICAgICAgLi4uZm4ocmVxdWlyZShuYW1lKSksXG4gICAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goYEZhaWxlZCB0byBsb2FkICR7bmFtZX06ICR7ZX1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCBvcHVzIG1vZHVsZSwgdHJpZWQgJHttb2R1bGVzLmxlbmd0aH0gZGlmZmVyZW50IG1vZHVsZXMuIEVycm9yczogJHtlcnJvcnMuam9pbignXFxuJyl9YCk7XG59O1xuXG5leHBvcnQgY29uc3QgQ1RMID0ge1xuICAgIEJJVFJBVEU6IDB4ZmEyLFxuICAgIEZFQzogMHhmYWMsXG4gICAgUExQOiAweGZhZVxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE9QVVNfTU9EX1JFR0lTVFJZOiBJTW9kW10gPSBbXG4gICAgW1xuICAgICAgICAnbWVkaWFwbGV4JyxcbiAgICAgICAgKG1vZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFtb2QuT3B1c0VuY29kZXIpIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWVkaWFwbGV4IHZlcnNpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB7IEVuY29kZXI6IG1vZC5PcHVzRW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgXSxcbiAgICBbJ0BkaXNjb3JkanMvb3B1cycsIChvcHVzKSA9PiAoeyBFbmNvZGVyOiBvcHVzLk9wdXNFbmNvZGVyIH0pXSxcbiAgICBbJ25vZGUtb3B1cycsIChvcHVzKSA9PiAoeyBFbmNvZGVyOiBvcHVzLk9wdXNFbmNvZGVyIH0pXSxcbiAgICBbJ29wdXNzY3JpcHQnLCAob3B1cykgPT4gKHsgRW5jb2Rlcjogb3B1cyB9KV1cbl07XG5cbmxldCBPcHVzOiB7IEVuY29kZXI/OiBJRW5jb2RlcjsgbmFtZT86IHN0cmluZyB9ID0ge307XG5cbmZ1bmN0aW9uIGxvYWRPcHVzKHJlZnJlc2ggPSBmYWxzZSkge1xuICAgIGlmIChPcHVzLkVuY29kZXIgJiYgIXJlZnJlc2gpIHJldHVybiBPcHVzO1xuXG4gICAgT3B1cyA9IGxvYWRNb2R1bGUoT1BVU19NT0RfUkVHSVNUUlkpO1xuICAgIHJldHVybiBPcHVzO1xufVxuXG5jb25zdCBjaGFyQ29kZSA9ICh4OiBzdHJpbmcpID0+IHguY2hhckNvZGVBdCgwKTtcbmNvbnN0IE9QVVNfSEVBRCA9IEJ1ZmZlci5mcm9tKFsuLi4nT3B1c0hlYWQnXS5tYXAoY2hhckNvZGUpKTtcbmNvbnN0IE9QVVNfVEFHUyA9IEJ1ZmZlci5mcm9tKFsuLi4nT3B1c1RhZ3MnXS5tYXAoY2hhckNvZGUpKTtcblxuZXhwb3J0IGludGVyZmFjZSBJT3B1c1N0cmVhbUluaXQge1xuICAgIGZyYW1lU2l6ZTogbnVtYmVyO1xuICAgIGNoYW5uZWxzOiBudW1iZXI7XG4gICAgcmF0ZTogbnVtYmVyO1xuICAgIGFwcGxpY2F0aW9uPzogbnVtYmVyO1xufVxuXG4vLyBmcmFtZSBzaXplID0gKGNoYW5uZWxzICogcmF0ZSAqIGZyYW1lX2R1cmF0aW9uKSAvIDEwMDBcblxuLyoqXG4gKiBUYWtlcyBhIHN0cmVhbSBvZiBPcHVzIGRhdGEgYW5kIG91dHB1dHMgYSBzdHJlYW0gb2YgUENNIGRhdGEsIG9yIHRoZSBpbnZlcnNlLlxuICogKipZb3Ugc2hvdWxkbid0IGRpcmVjdGx5IGluc3RhbnRpYXRlIHRoaXMgY2xhc3MsIHNlZSBvcHVzLkVuY29kZXIgYW5kIG9wdXMuRGVjb2RlciBpbnN0ZWFkISoqXG4gKiBAbWVtYmVyb2Ygb3B1c1xuICogQGV4dGVuZHMgVHJhbnNmb3JtU3RyZWFtXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBPcHVzU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICBwdWJsaWMgZW5jb2RlcjogSW5zdGFuY2VUeXBlPElFbmNvZGVyPiB8IG51bGwgPSBudWxsO1xuICAgIHB1YmxpYyBfb3B0aW9uczogSU9wdXNTdHJlYW1Jbml0O1xuICAgIHB1YmxpYyBfcmVxdWlyZWQ6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdXMgdHJhbnNmb3JtZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbWVtYmVyb2Ygb3B1c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyB0aGF0IHlvdSB3b3VsZCBwYXNzIHRvIGEgcmVndWxhciBUcmFuc2Zvcm0gc3RyZWFtXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9IGFzIElPcHVzU3RyZWFtSW5pdCkge1xuICAgICAgICBpZiAoIWxvYWRPcHVzKCkuRW5jb2Rlcikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGFuIE9wdXMgbW9kdWxlISBQbGVhc2UgaW5zdGFsbCBvbmUgb2YgJHtPUFVTX01PRF9SRUdJU1RSWS5tYXAoKG8pID0+IG9bMF0pLmpvaW4oJywgJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUgfSwgb3B0aW9ucykpO1xuXG4gICAgICAgIGNvbnN0IGxpYiA9IE9wdXMgYXMgUmVxdWlyZWQ8dHlwZW9mIE9wdXM+O1xuXG4gICAgICAgIGlmIChsaWIubmFtZSA9PT0gJ29wdXNzY3JpcHQnKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFwcGxpY2F0aW9uID0gbGliLkVuY29kZXIuQXBwbGljYXRpb24hW29wdGlvbnMuYXBwbGljYXRpb24hXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyBsaWIuRW5jb2RlcihvcHRpb25zLnJhdGUsIG9wdGlvbnMuY2hhbm5lbHMsIG9wdGlvbnMuYXBwbGljYXRpb24hKTtcblxuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSB0aGlzLl9vcHRpb25zLmZyYW1lU2l6ZSAqIHRoaXMuX29wdGlvbnMuY2hhbm5lbHMgKiAyO1xuICAgIH1cblxuICAgIF9lbmNvZGUoYnVmZmVyOiBCdWZmZXIpIHtcbiAgICAgICAgaWYgKE9wdXMubmFtZSA9PT0gJ29wdXNzY3JpcHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyIS5lbmNvZGUoYnVmZmVyLCB0aGlzLl9vcHRpb25zLmZyYW1lU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyIS5lbmNvZGUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kZWNvZGUoYnVmZmVyOiBCdWZmZXIpIHtcbiAgICAgICAgaWYgKE9wdXMubmFtZSA9PT0gJ29wdXNzY3JpcHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyIS5kZWNvZGUoYnVmZmVyLCB0aGlzLl9vcHRpb25zLmZyYW1lU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVyIS5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9wdXMgbW9kdWxlIGJlaW5nIHVzZWQgLSBgb3B1c3NjcmlwdGAsIGBub2RlLW9wdXNgLCBvciBgQGRpc2NvcmRqcy9vcHVzYC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc29sZS5sb2coYFVzaW5nIE9wdXMgbW9kdWxlICR7cHJpc20ub3B1cy5FbmNvZGVyLnR5cGV9YCk7XG4gICAgICovXG4gICAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gT3B1cy5uYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJpdHJhdGUgb2YgdGhlIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0cmF0ZSB0aGUgYml0cmF0ZSB0byB1c2UgdXNlLCBlLmcuIDQ4MDAwXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldEJpdHJhdGUoYml0cmF0ZTogbnVtYmVyKSB7XG4gICAgICAgICh0aGlzLmVuY29kZXIhLmFwcGx5RW5jb2RlckNUTCEgfHwgdGhpcy5lbmNvZGVyIS5lbmNvZGVyQ1RMKS5hcHBseSh0aGlzLmVuY29kZXIhLCBbQ1RMLkJJVFJBVEUsIE1hdGgubWluKDEyOGUzLCBNYXRoLm1heCgxNmUzLCBiaXRyYXRlKSldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGZvcndhcmQgZXJyb3IgY29ycmVjdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgd2hldGhlciBvciBub3QgdG8gZW5hYmxlIEZFQy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0RkVDKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgKHRoaXMuZW5jb2RlciEuYXBwbHlFbmNvZGVyQ1RMISB8fCB0aGlzLmVuY29kZXIhLmVuY29kZXJDVEwpLmFwcGx5KHRoaXMuZW5jb2RlciEsIFtDVEwuRkVDLCBlbmFibGVkID8gMSA6IDBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBleHBlY3RlZCBwYWNrZXQgbG9zcyBvdmVyIG5ldHdvcmsgdHJhbnNtaXNzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyY2VudGFnZV0gYSBwZXJjZW50YWdlIChyZXByZXNlbnRlZCBiZXR3ZWVuIDAgYW5kIDEpXG4gICAgICovXG4gICAgc2V0UExQKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICAodGhpcy5lbmNvZGVyIS5hcHBseUVuY29kZXJDVEwhIHx8IHRoaXMuZW5jb2RlciEuZW5jb2RlckNUTCkuYXBwbHkodGhpcy5lbmNvZGVyISwgW0NUTC5QTFAsIE1hdGgubWluKDEwMCwgTWF0aC5tYXgoMCwgcGVyY2VudGFnZSAqIDEwMCkpXSk7XG4gICAgfVxuXG4gICAgX2ZpbmFsKGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG5cbiAgICBfZGVzdHJveShlcnI6IEVycm9yIHwgbnVsbCwgY2I6IChlcnI6IEVycm9yIHwgbnVsbCkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybiBjYiA/IGNiKGVycikgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHRoZSBPcHVzIHN0cmVhbSB3aGVuIGl0IGlzIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jbGVhbnVwKCkge1xuICAgICAgICBpZiAoT3B1cy5uYW1lID09PSAnb3B1c3NjcmlwdCcgJiYgdGhpcy5lbmNvZGVyISkgdGhpcy5lbmNvZGVyIS5kZWxldGUhKCk7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEFuIE9wdXMgZW5jb2RlciBzdHJlYW0uXG4gKlxuICogT3V0cHV0cyBvcHVzIHBhY2tldHMgaW4gW29iamVjdCBtb2RlLl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9zdHJlYW0uaHRtbCNzdHJlYW1fb2JqZWN0X21vZGUpXG4gKiBAZXh0ZW5kcyBvcHVzLk9wdXNTdHJlYW1cbiAqIEBtZW1iZXJvZiBvcHVzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZW5jb2RlciA9IG5ldyBwcmlzbS5vcHVzLkVuY29kZXIoeyBmcmFtZVNpemU6IDk2MCwgY2hhbm5lbHM6IDIsIHJhdGU6IDQ4MDAwIH0pO1xuICogcGNtQXVkaW8ucGlwZShlbmNvZGVyKTtcbiAqIC8vIGVuY29kZXIgd2lsbCBub3cgb3V0cHV0IE9wdXMtZW5jb2RlZCBhdWRpbyBwYWNrZXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBPcHVzRW5jb2RlciBleHRlbmRzIE9wdXNTdHJlYW0ge1xuICAgIF9idWZmZXI6IEJ1ZmZlciB8IG51bGwgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdXMgZW5jb2RlciBzdHJlYW0uXG4gICAgICogQG1lbWJlcm9mIG9wdXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIHRoYXQgeW91IHdvdWxkIHBhc3MgdG8gYSByZWd1bGFyIE9wdXNTdHJlYW0sIHBsdXMgYSBmZXcgbW9yZTpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5mcmFtZVNpemUgdGhlIGZyYW1lIHNpemUgaW4gYnl0ZXMgdG8gdXNlIChlLmcuIDk2MCBmb3Igc3RlcmVvIGF1ZGlvIGF0IDQ4S0h6IHdpdGggYSBmcmFtZVxuICAgICAqIGR1cmF0aW9uIG9mIDIwbXMpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2hhbm5lbHMgdGhlIG51bWJlciBvZiBjaGFubmVscyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5yYXRlIHRoZSBzYW1wbGluZyByYXRlIGluIEh6XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9IGFzIElPcHVzU3RyZWFtSW5pdCkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rOiBCdWZmZXIsIGVuY29kaW5nOiBCdWZmZXJFbmNvZGluZywgZG9uZTogKCkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuY29uY2F0KFt0aGlzLl9idWZmZXIhLCBjaHVua10pO1xuICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLl9idWZmZXIubGVuZ3RoID49IHRoaXMuX3JlcXVpcmVkICogKG4gKyAxKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gdGhpcy5fZW5jb2RlKHRoaXMuX2J1ZmZlci5zbGljZShuICogdGhpcy5fcmVxdWlyZWQsIChuICsgMSkgKiB0aGlzLl9yZXF1aXJlZCkpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPiAwKSB0aGlzLl9idWZmZXIgPSB0aGlzLl9idWZmZXIuc2xpY2UobiAqIHRoaXMuX3JlcXVpcmVkKTtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG5cbiAgICBfZGVzdHJveShlcnI6IEVycm9yLCBjYjogKGVycjogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgICAgIHN1cGVyLl9kZXN0cm95KGVyciwgY2IpO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbiBPcHVzIGRlY29kZXIgc3RyZWFtLlxuICpcbiAqIE5vdGUgdGhhdCBhbnkgc3RyZWFtIHlvdSBwaXBlIGludG8gdGhpcyBtdXN0IGJlIGluXG4gKiBbb2JqZWN0IG1vZGVdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX29iamVjdF9tb2RlKSBhbmQgc2hvdWxkIG91dHB1dCBPcHVzIHBhY2tldHMuXG4gKiBAZXh0ZW5kcyBvcHVzLk9wdXNTdHJlYW1cbiAqIEBtZW1iZXJvZiBvcHVzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZGVjb2RlciA9IG5ldyBwcmlzbS5vcHVzLkRlY29kZXIoeyBmcmFtZVNpemU6IDk2MCwgY2hhbm5lbHM6IDIsIHJhdGU6IDQ4MDAwIH0pO1xuICogaW5wdXQucGlwZShkZWNvZGVyKTtcbiAqIC8vIGRlY29kZXIgd2lsbCBub3cgb3V0cHV0IFBDTSBhdWRpb1xuICovXG5leHBvcnQgY2xhc3MgT3B1c0RlY29kZXIgZXh0ZW5kcyBPcHVzU3RyZWFtIHtcbiAgICBfdHJhbnNmb3JtKGNodW5rOiBCdWZmZXIsIGVuY29kaW5nOiBCdWZmZXJFbmNvZGluZywgZG9uZTogKGU/OiBFcnJvciB8IG51bGwsIGNodW5rPzogQnVmZmVyKSA9PiB2b2lkKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGNodW5rLnNsaWNlKDAsIDgpO1xuICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID49IDggJiYgc2lnbmF0dXJlLmVxdWFscyhPUFVTX0hFQUQpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Zvcm1hdCcsIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsczogdGhpcy5fb3B0aW9ucy5jaGFubmVscyxcbiAgICAgICAgICAgICAgICBzYW1wbGVSYXRlOiB0aGlzLl9vcHRpb25zLnJhdGUsXG4gICAgICAgICAgICAgICAgYml0RGVwdGg6IDE2LFxuICAgICAgICAgICAgICAgIGZsb2F0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaWduZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogY2h1bmsucmVhZFVJbnQ4KDgpLFxuICAgICAgICAgICAgICAgIHByZVNraXA6IGNodW5rLnJlYWRVSW50MTZMRSgxMCksXG4gICAgICAgICAgICAgICAgZ2FpbjogY2h1bmsucmVhZFVJbnQxNkxFKDE2KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuay5sZW5ndGggPj0gOCAmJiBzaWduYXR1cmUuZXF1YWxzKE9QVVNfVEFHUykpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndGFncycsIGNodW5rKTtcbiAgICAgICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9kZWNvZGUoY2h1bmspKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoZSBhcyBFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW5mZXJyYWJsZS10eXBlc1xuZXhwb3J0IGNvbnN0IHZlcnNpb246IHN0cmluZyA9ICcwLjEuMSc7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBLG9CQUEwQjtBQTBCMUIsSUFBTSxhQUFhLHdCQUNmLFlBSUM7QUFDRCxRQUFNLFNBQW1CLENBQUM7QUFFMUIsYUFBVyxDQUFDLE1BQU0sRUFBRSxLQUFLLFNBQVM7QUFDOUIsUUFBSTtBQUNBLGFBQU87QUFBQSxRQUVILEdBQUcsR0FBRyxRQUFRLEtBQUs7QUFBQSxRQUNuQjtBQUFBLE1BQ0o7QUFBQSxJQUNKLFNBQVMsR0FBUDtBQUNFLGFBQU8sS0FBSyxrQkFBa0IsU0FBUyxHQUFHO0FBQzFDO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFFQSxR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