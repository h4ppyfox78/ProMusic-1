{"version":3,"sources":["../src/index.ts","../src/Music/Music.ts","../src/Music/Track.ts","../src/Music/Playlist.ts","../src/Utils/APIs.ts","../src/Utils/StringUtils.ts","../src/Utils/Utils.ts"],"sourcesContent":["export { Music, Playlist, Track } from './Music';\nexport { APIs, Utils, StringUtils } from './Utils';\nimport { DeezerAlbum, DeezerPlaylist, SoundCloud, Spotify } from 'play-dl';\nimport { Music, Playlist, Track } from './Music';\n\n/**\n * Searches for a track or a playlist on youtube\n * @param {string} query: string | url\n * @returns Promise<Track[] | Playlist[]>\n */\n\nexport async function youtube(query: string): Promise<Track[] | Playlist[]> {\n  return await new Music().youtube(query);\n}\n\n/**\n *  Searches for a track, playlist or album on deezer\n * @param {string} query\n * @returns Promise<Track | Playlist | DeezerAlbum | DeezerPlaylist>\n */\n\nexport async function deezer(\n  query: string\n): Promise<Track | Playlist | DeezerAlbum | DeezerPlaylist> {\n  return await new Music().deezer(query);\n}\n\n/**\n * Searches for a track, playlist or album on Spotify\n * @param {string} query\n * @returns Promise<Spotify>\n */\n\nexport async function spotify(query: string): Promise<Spotify> {\n  return await new Music().spotify(query);\n}\n\n/**\n * Gets a track or a playlist from Soundcloud\n * @param {string} query\n * @returns Promise<SoundCloud>\n */\n\nexport async function soundcloud(query: string): Promise<SoundCloud> {\n  return await new Music().soundcloud(query);\n}\n","import {\n  yt_validate,\n  search,\n  deezer,\n  spotify,\n  sp_validate,\n  dz_validate,\n  Spotify,\n  DeezerAlbum,\n  DeezerPlaylist,\n  SoundCloud,\n  so_validate,\n  soundcloud\n} from 'play-dl';\nimport { Track } from './Track';\nimport { Playlist } from './Playlist';\n\nexport class Music {\n  /**\n   * Searches for a track or a playlist on youtube\n   * @param {string} query: string | url\n   * @returns Promise<Track[] | Playlist[]>\n   */\n\n  async youtube(query: string): Promise<Track[] | Playlist[]> {\n    if (!query) throw new Error('No search query was provided!');\n    const validate = yt_validate(query);\n    if (!validate) throw new Error('This is not a valid search query!');\n\n    let tracks;\n    let result: any;\n    console.log(validate);\n    switch (validate) {\n      case 'video':\n        result = await search(query);\n        if (!result) throw new Error('This Track was not found!');\n        tracks = result.map((track: any) => {\n          console.log(track);\n          return new Track(track);\n        });\n        break;\n      case 'search':\n        result = await search(query);\n        if (!result) throw new Error('No Song was found for this query!');\n        tracks = result.map((track: any) => {\n          console.log(track.thumbnails[0].url);\n          return new Track(track);\n        });\n        break;\n    }\n\n    return tracks;\n  }\n\n  /**\n   *  Searches for a track, playlist or album on deezer\n   * @param {string} query\n   * @returns Promise<Track | Playlist | DeezerAlbum | DeezerPlaylist>\n   */\n  async deezer(\n    query: string\n  ): Promise<Track | Playlist | DeezerAlbum | DeezerPlaylist> {\n    if (!query) throw new Error('No search query was provided!');\n    const validate = await dz_validate(query);\n    if (!validate) throw new Error('This is not a valid search query!');\n    let tracks;\n    let result: any;\n    switch (validate) {\n      case 'search':\n        result = await search(query, { source: { deezer: 'track' } });\n        tracks = result.map((track: any) => {\n          return new Track(track);\n        });\n        break;\n      case 'playlist':\n        result = await deezer(query);\n        tracks = result;\n        break;\n      case 'track':\n        result = await search(query, { source: { deezer: 'track' } });\n        tracks = result.map((track: any) => {\n          return new Track(track);\n        });\n        break;\n      case 'album':\n        result = await deezer(query);\n        tracks = result;\n        break;\n    }\n    return tracks;\n  }\n\n  /**\n   * Searches for a track, playlist or album on Spotify\n   * @param {string} query\n   * @returns Promise<Spotify>\n   */\n\n  async spotify(query: string): Promise<Spotify> {\n    if (!query) throw new Error('No search query was provided!');\n    const validate = sp_validate(query);\n    if (!validate) throw new Error('This is not a valid search query!');\n\n    return await spotify(query);\n  }\n\n  /**\n   * Gets a track or a playlist from Soundcloud\n   * @param {string} query\n   * @returns Promise<SoundCloud>\n   */\n  async soundcloud(query: string): Promise<SoundCloud> {\n    if (!query) throw new Error('No search query was provided!');\n    const validate = so_validate(query);\n    if (!validate) throw new Error('This is not a valid search query!');\n\n    return await soundcloud(query);\n  }\n}\n","export interface TrackData {\n  durationInSec: number;\n  title: string;\n  url: string;\n  thumbnails?: any[];\n  duration: string;\n  type: string;\n  description?: string;\n  views?: number;\n  channel?: { name: string; url: string };\n  private?: boolean;\n  shortTitle?: string;\n  rank?: number;\n  explicit?: string;\n  previewURL?: string;\n  artist?: { id: number; name: string; url: string; picture: {} };\n  album?: {};\n}\n\nexport class Track {\n  title: string;\n  url: string;\n  thumbnails?: any[];\n  duration: number;\n  type: string;\n  description?: string;\n  views?: number;\n  channel?: {};\n  private?: boolean;\n  shortTitle?: string;\n  rank?: number;\n  explicit?: string;\n  previewURL?: string;\n  artist?: { id: number; name: string; url: string; picture: {} };\n  album?: {};\n\n  constructor(track: TrackData) {\n    if (!track) throw new Error('Constructor was not initialized properly!');\n    this.title = track.title;\n    this.url = track.url;\n    this.thumbnails = track?.thumbnails || undefined;\n    this.duration = track?.durationInSec;\n    this.type = track.type;\n    this.description = track?.description;\n    this.views = track?.views;\n    this.channel = {\n      name: track?.channel?.name,\n      url: track?.channel?.url\n    };\n    this.private = track?.private;\n    this.shortTitle = track?.shortTitle;\n    this.rank = track?.rank;\n    this.explicit = track?.explicit;\n    this.previewURL = track?.previewURL;\n    this.artist = track?.artist;\n    this.album = track?.album;\n  }\n}\n","import { TrackData } from './Track';\n\ninterface PlayList {\n  type: string;\n  id: string;\n  url: string;\n  title: string;\n  videoCount: number;\n  channel: { type: string; name: string; url: string };\n  thumbnail: string;\n  videos: TrackData[];\n}\n\nexport class Playlist {\n  type: string;\n  id: string;\n  url: string;\n  title: string;\n  videoCount: number;\n  channel: {};\n  thumbnail: string;\n  videos: TrackData[];\n\n  constructor(playlist: PlayList) {\n    this.type = playlist.type;\n    this.id = playlist.id;\n    this.url = playlist.url;\n    this.title = playlist.title;\n    this.videoCount = playlist.videoCount;\n    this.channel = playlist.channel;\n    this.thumbnail = playlist.thumbnail;\n    this.videos = playlist.videos;\n  }\n}\n","import fetch, { RequestInit } from 'node-fetch';\nconst jikanjs = require('jikanjs');\njikanjs.settings.setBaseURL('https://api.jikan.moe/v3', 3);\n\nclass APIs {\n  protected ShowID: string | undefined;\n  protected MovieID: string | undefined;\n  public TMDBKey: string;\n\n  constructor(TMDBKey: string) {\n    this.TMDBKey = TMDBKey;\n  }\n\n  /**\n   * Gets the Show ID from TheMovieDB\n   * @param {string} query\n   * @param {string} key\n   * @returns {string} the Show ID\n   */\n\n  private async getShowID(query: string): Promise<any> {\n    try {\n      const req = await fetch(\n        `https://api.themoviedb.org/3/search/tv?api_key=${this.TMDBKey}&language=en-US&query=${query}`\n      );\n      const res: any = await req.json();\n      return (this.ShowID = res.results[0].id);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * Gets a Show Info from TheMovieDB\n   * @param query\n   * @param key\n   * @returns {object} ShowInfo\n   */\n\n  async getShowDetails(query: string, key: string): Promise<any> {\n    if (!key) throw new Error('A TMDB API Key is required!');\n    try {\n      await this.getShowID(query);\n      const req = await fetch(\n        `https://api.themoviedb.org/3/tv/${this.ShowID}?api_key=${this.TMDBKey}&language=en-US`\n      );\n      const res = await req.json();\n      return res;\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  /**\n   * Gets an Anime Info from MyAnimeList\n   * @param {string} query\n   * @param {string} type\n   * @returns {object}\n   */\n\n  async getAnimeInfo(query: string, type: string = 'anime'): Promise<{}> {\n    try {\n      const getId = await jikanjs.search(type, query, [1]);\n      const animeId = getId.results[0].mal_id;\n      const getFullInfo = await jikanjs.loadAnime(animeId, '/');\n      const genresArray = getFullInfo.genres.map(\n        (element: any) => element.name\n      );\n\n      return {\n        malid: getFullInfo.mal_id,\n        imageUrl: getFullInfo.image_url,\n        titlerom: getFullInfo.title,\n        titleeng: getFullInfo.title_english,\n        episodes: getFullInfo.episodes,\n        status: getFullInfo.status,\n        rating: getFullInfo.rating,\n        score: getFullInfo.score,\n        rank: getFullInfo.rank,\n        synopsis: getFullInfo.synopsis,\n        premiered: getFullInfo.premiered,\n        genres: genresArray,\n        aired: getFullInfo.aired.string\n      };\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * Gets a Movie ID from TheMovieDB\n   * @param {string} query\n   * @param {string | number} year\n   * @param {string} key\n   * @returns {string} The Movie ID\n   */\n\n  private async getMovieID(query: string): Promise<string> {\n    try {\n      const req = await fetch(\n        `https://api.themoviedb.org/3/search/movie?api_key=${this.TMDBKey}&language=en-US&query=${query}`\n      );\n      const res: any = await req.json();\n      if (!res.total_results)\n        throw new Error(`${'Nothing found with this name!'}`);\n\n      return (this.MovieID = res.results[0].id);\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * Gets a Movie Info from TheMovieDB\n   * @param {string} query\n   * @param {string | number} year\n   * @param {string} key\n   * @returns {object} MovieInfo\n   */\n\n  async getMovieDetails(query: string, key: string): Promise<{}> {\n    if (!key) throw new Error('A TMDB API Key is required!');\n    try {\n      await this.getMovieID(query);\n      const req = await fetch(\n        `https://api.themoviedb.org/3/movie/${this.MovieID}?api_key=${this.TMDBKey}&language=en-US`\n      );\n      const res: any = await req.json();\n      return res;\n    } catch (err) {\n      throw err;\n    }\n  }\n\n  /**\n   * Simple function to perform GET Requests\n   * @param {string} url the link\n   * @param {object} options node-fetch additional options\n   * @returns JSON\n   */\n\n  async request(url: string, options: RequestInit = {}): Promise<any> {\n    try {\n      const request = await fetch(url, options);\n      const responseToJson = await request.json();\n      return responseToJson;\n    } catch (err) {\n      throw err;\n    }\n  }\n}\nexport { APIs };\n","class StringUtils {\n  /**\n   * Chunks a single string into multiple multiple strings\n   * @param {string} str the string\n   * @param {number} size chunk by length\n   * @returns Array containing the chunked strings\n   */\n\n  chunkSubString(str: string, size: number): string[] {\n    const numChunks = Math.ceil(str.length / size);\n    const chunks = new Array(numChunks);\n\n    for (let i = 0, o = 0; i < numChunks; ++i, o += size) {\n      chunks[i] = str.substr(o, size);\n    }\n\n    return chunks;\n  }\n\n  /**\n   * A simple random password generator\n   * @param {number} length\n   * @returns string\n   */\n\n  RandomPasswordGenerator(length: number): string {\n    const validCharacters =\n      'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890?!$';\n    const maximalLength = length;\n    let result = '';\n\n    for (let i = 0; i < maximalLength; i++) {\n      const randomNumber = Math.floor(Math.random() * validCharacters.length);\n      result += validCharacters[randomNumber];\n    }\n\n    return result;\n  }\n\n  /**\n   * Simple function that creates multiple random passwords\n   * @param {number} howMany number of passwords to generate\n   * @param {number} passwordlength length of the password\n   * @returns str[] of random passwords\n   */\n\n  GenerateABunchOfRandomPasswords(\n    howMany: number,\n    passwordlength: number\n  ): string[] {\n    let result = [];\n\n    for (let i = 0; i < howMany; i++) {\n      result.push(this.RandomPasswordGenerator(passwordlength));\n    }\n\n    return result;\n  }\n}\nexport { StringUtils };\n","import mongoose from 'mongoose';\nimport chalk from 'chalk';\nimport moment from 'moment';\n\nclass Utils {\n  /**\n   * Logger for the console\n   * @param {string} message Error Message\n   * @param {string} type Error Or Log\n   * @returns void\n   */\n\n  logger(message: string | unknown, type: string = 'log'): void {\n    const date = `${moment().format('DD-MM-YYYY hh:mm:ss')}`;\n\n    switch (type) {\n      case 'log':\n        return console.log(\n          `[${chalk.gray(date)}]: [${chalk.black.bgGreen(\n            type.toUpperCase()\n          )}] ${message}`\n        );\n      case 'error':\n        return console.log(\n          `[${chalk.gray(date)}]: [${chalk.black.bgRed(\n            type.toUpperCase()\n          )}] ${message}`\n        );\n      default:\n        throw new TypeError('Logger type must be either log or error!');\n    }\n  }\n\n  /**\n   * Creates a connection to a mongodb Database using mongoose\n   * @param {string} mongourl\n   */\n\n  connectToDataBase(mongourl: string): void {\n    const dbOptions = {\n      useNewUrlParser: true,\n      autoIndex: false,\n      connectTimeoutMS: 10000,\n      family: 4,\n      useUnifiedTopology: true\n    };\n    mongoose.connect(mongourl, dbOptions);\n    mongoose.Promise = global.Promise;\n    mongoose.connection.on('connected', () => {\n      this.logger('[DB] DATABASE CONNECTED');\n    });\n    mongoose.connection.on('err', (err) => {\n      this.logger(`Mongoose connection error: \\n ${err.stack}`, 'error');\n    });\n    mongoose.connection.on('disconnected', () => {\n      this.logger('Mongoose disconnected', 'error');\n    });\n  }\n}\nexport { Utils };\n"],"mappings":"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","names":[]}